# Lab 1 

## 实验报告

- ### **Git & GitHub仓库**

  >创建OSH-2021-Labs
  >
  >使用git上传文件

- ### **Linux内核**

  >**实验步骤：** 
  >
  >1. 配置环境
  >2. 安装QEMU
  >3. 下载源码
  >4. 编译内核
  >5. 修改`.config`文件
  >6. 编译内核
  >7. 运行QEMU检查内核是否正常运行[Image大于6MB跳至5.]
  >8. 结束
  >
  >**实验感悟：**
  >
  >1. 模块是真的多
  >
  >   2.有很多模块卸载掉不仅没有减小Image的大小，反而居然增加了Image的大小
  >
  >3. 有一个模块卸载掉会使得Image文件的种类从DOS变为Program
  >4. 裁剪到最后基本上各个模块都删掉了，内核要能“跑“需要的核心模块很少，外围的模块反而占很大内存
  >5. 手累
  >
  >**实验结果：**得到了一个能正确运行initrd.cpio.gz文件,且不出现Kernel Panic的大小为5.6MB的Image

  

- ### **初始化内存盘**

  >**实验步骤：**
  >
  >1. 下载BusyBox的binary文件
  >2. 编写`rootfs/init`文件
  >3. 打包为`initrd.cpio.gz`
  >4. 运行QEMU
  >
  >**实验感悟：**
  >
  >1. BusyBox提供了很多Shell命令，直接调用实在是太方便了
  >2. 这份BusyBox中的`/bin/sh`似乎不能正常使用，一直是无法连接到tty0
  >3. 在生成可执行文件的时候一定要用交叉编译（
  >4. 不能忘记创建设备文件，毕竟要进行文件的读写操作
  >
  >**实验结果：**得到了一个能创建设备文件，能运行助教提供的1，2，3文件，最后不会进入Kernel Panic的`init.cpio.gz`

  

- ### **初识Boot**

  >**实验步骤：** 
  >
  >1. 配置环境
  >2. 下载源码
  >3. 使用`Makefile`完成编译与测试
  >4. 修改代码增加一行输出“I am OK!”
  >
  >**实验问题回答**：
  >
  >1. `Makefile`**使用正确的指令:** `make all`
  >
  >2. `boot.asm` **文件前侧的** `org 0x7c00` **有什么用?**
  >
  >  **答：**指定将该程序装载到0x7c00的位置上
  >
  >​		从0x0007c00到0x00007dff是启动区内容的装载地址
  >
  >3. `times 510 - ($ - $$) db 0` **是在干什么？为什么要这么做呢？为什么这里有一个** `510`**？**
  >
  >  **答**：从此处开始向内存中0x00,直到第510个字节，其中$可以得到这一行现在的字节数，相减便得到从现在位置到第510个字节之间的字节数，并填入0x00
  >
  >​		因为之后要向第510和511字节里面写入0x55AA
  >
  >​		根据规定，在第一个扇区的最后两个字节，也就是第510-511字节上的字节为0x55AA时，认为该扇区开头为启动程序并执行	
  >
  >4. 尝试修改代码，在目前已有的输出中增加一行输出“I am OK!”，样式不限，位置不限，但不能覆盖其他的输出
  >
  >  **答：**已体现在QEMU运行结果中

    

- ### **思考题**

  >1. **简述树莓派启动的各个阶段。**
  >
  >   **答：**
  >
  >   - 第一阶段：从系统芯片中加载启动程序，该启动程序将挂在SD卡中的FAT32文件系统,其中就包含`bootcode.bin`
  >   - 第二阶段：运行`bootcode.bin`从SD上检索GPU固件`start.elf`并运行。首先读取系统配置文件`config.txt`,之后读取`cmdline.txt`和`kernel.img`。其中`cmdline.txt`包含了内核运行的参数，`kernel.image`则将被加载到处理器分配的共享内存中。内核加载成功后，系统启动正式开始
  >
  >2. **查阅**`PXE`**的资料，用自己的话描述它启动的过程**
  >
  >   **答：**
  >
  >   1. `PXE`固件使用`UDP`数据包获取TCP与IP的详细信息
  >
  >   2. `DHCP`服务器相应请求，发送数据包，告知客户端它为地址服务器
  >
  >   3. `PXE`服务器响应客户端，发送数据包，并报告它为启动服务器
  >
  >   4. 客户端向`DHCP`服务器请求IP地址
  >
  >   5. `DHCP`服务器将IP地址发送给客户端`
  >   6. 客户端向`PXE`服务器请求`NBP`进行网络启动
  >
  >   7. `PXE`服务器响应，发送`NBP`路径
  >
  >   8. 客户端下载并运行`NBP`
  >
  >   （9. 由`NBP`控制客户端与`PXE`服务器间进行更多的交互）
  >
  >3. **查阅** `GRUB` **的资料，用自己的话描述它启动的过程**
  >
  >   **答：**
  >
  >   1. 读取grub所在磁盘的MBR，同时加载stage1，stage1.5
  >   2. 运行位于MBR中的Boot Loader主程序，在stage1.5的帮助下，引导装载stage2
  >   3. 加载GRUB配置文件/boot/grub/grub.config
  >   4. grub根据配置文件中的定义载入内核bzImage并展开至指定位置，同时载入initrd.img到内存
  >
  >4. **说明** `UEFI Boot` **的流程，截图指出你的某一个系统的** `EFI` **分区中包含哪些文件**
  >
  >   **答：**
  >
  >   1. SEC阶段：接收UEFI系统启动、加电等信号，初始化临时储存区域，作为可信系统的根，将参数传递给下一阶段。
  >   2. PEI阶段：初始化PS，调度系统中的PEIM，准备HOB列表，加载DXE
  >   3. DXE阶段：根据HOB列表初始化系统服务，调度系统中的Driver,打开EFI_BDS_ARCH_PROTOCOL，进入BDS
  >   4. BDS阶段：初始化控制台设备，家在必要的设备驱动，根据系统设置加载与执行启动项
  >   5. TSL阶段：运行OS Loader，调用ExitBootServices()，进入RT阶段
  >   6. RT阶段：UEFI内核将系统控制权交给OS Loader，OS Loader逐步回收UEFI占用的各种资源，最终取得对系统的控制权
  >   7. AL阶段：若系统出现灾难性的错误，系统固件提供错误处理与灾难恢复机制
